# AvitoTech
Микросервис предоставляет HTTP API для работы с баннерами пользователей. Реализованы следующие функции:
* Получение баннера для пользователя
* Получение всех баннеров с фильтрацией по фиче и/или тегу
* Создание нового баннера
* Обновление содержимого баннера
* Удаление баннера по индефикатору

Каждый запрос принимает JWT токен для авторизации доступа. Существует 2 вида токенов: пользовательский и админский. Баннер пользователя может получить как пользователь, так и админ. Все остальные запросы требуют токен администратора.

Были так же выполнены дополнительные функции:
* Начал писать unit тесты
* Написал интеграционный тест для разных сюжетов по получении баннера
* Описал конфигурацию линтера
* Добавил кэш в приложение, для ускорение получения ответа на самые популярные запросы

## Реализация

Микросервис разработан на Go. Для хранения информации используется реляционная СУБД - PostgreSQL. Сервис запускается в среде docker-compose, один контейнер для БД, другой для сервиса. Так же для интеграционных тестов можно поднять docker-compose с двумя контейнерами. Для тестов в ходе инициализации БД создаются фикстуры.

В качестве фреймворка для рутинга был выбран фреймворк [Fiber](https://github.com/gofiber/fiber). Он очень похож на другие рутинг фреймворки, но существенно выигрывает по скорости.

В качестве драйвера для работы с PostgreSQL на Go был выбран [PGX](https://github.com/jackc/pgx), как современное
и быстрое решение. В нем реализованно множество функций, как и в общем SQL, так и конкретно
PostgreSQL.

В качестве библиотеки для линтера был выбран [Golangci-lint](https://github.com/golangci/golangci-lint), потому что с помощью удобной конфигурации получилось добавить дополнительные проверки из других линтеров.

## Запуск

Есть Makefile со сценариями  integration_test, build, stop.
1. Сценарий integration_test поднимает докер контейнеры сервиса и БД, проводит интеграционные тесты и запускаются, после удаляет эти контейнеры.
2. Сценарий build зависит от integration_test, поэтому сначала запустится сценарий под номером 1, потом запустится build.
3. Сценарий stop останавливает контейнеры.

Рекомендуется запускать через команду 'make build'

## Что не получилось

Не хватило времени, чтобы провести нагрузочное тестирование, добавить версионирование баннеров, добавить удаление баннеров за временной период в 100 мс и написать интеграционные тесты на все сценарии использования. Так же в коде в TODO написал свои мысли и желания, которые не успел реализовать.

## Вопросы

1. Для запроса DELETE banner написано, что нужно удалять баннер по индификатору. Сразу подумал о id, но позже увидел, что в ошибках есть пункт: 404
Баннер для тэга не найден. Решил, что это опечатка и надо все таки удалять только по id банера, так как нельзя индифицировать сущность только по id тэга или id фичи.

2. По заданию сказано, что запросы должны обрабатывать разного уровня доступа токены. Не понятно, как это сделать без таблицы пользователей и ролей, поэтому создаются таблицы users и roles, в которые сразу происходит insert двух пользователей: первый с id = 1 и ролью admin = true, второй с id = 2 и ролью admin = false. Это важно учесть при создании токена. Это при учете того, что было принятно мной решение, что не совсем правильно хранить уровень доступа пользователя в токене.

## Запросы

Запросы можно протестировать через Postman (в корне проекта лежит коллекция запросов из Postman). ВАЖНО, что каждый запрос принимает в header "Authorization" токен пользователя. Запрос для получения баннера пользователя отработает с токеном админа и пользователя. Остальные запросы работают только с токеном администратора. Закрытый ключ лежит в файле .env
Список обрабатываемых запросов:
1. GET /api/user_banner - Возвращает баннер пользователя. Запрос обязательно в query должен принимать tag_id и feature_id
2. GET /api/banner - Получение всех баннеров с фильтрацией по фиче и/или тегу. Запрос должен принимать в query feature_id или/и tag_id. Так же можно передать дополнительные параметры: limit и offset.
3. POST /api/banner - Создание нового баннера. В теле запроса должен быть JSON объект, в котором есть поля: tag_ids, feature_id, content, is_active
4. PATCH /api/banner/{id} - Обновление содержимого баннера. Так же тело запроса должно содержать JSON объект из предыдущего запроса
5. DELETE /api/banner/{id} - Удаление баннера по идентификатору. Запрос должен содержать id баннера
